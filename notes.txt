

2018-12-28
	* Text Encoding
		* Includes "decimal", "hex", and "base64" as variations of general TextEncoding.  Some 
			types require this distinction (e.g. int var = Memory{"1234"}.asHex()).
		* Accomplishes what "to_string" is generally used for.  Encoding as text is generally 
			provided through toString() member function.
		* Text Encoding is almost always used for discrete values, not for streamed operations.  
			For this reason encoding is performed to/from String/Memory objects, and the decode
			operation is performed using a constructor from a EncodedText type.
	* Binary Encoding
		* Binary Encoding is almost always used for streaming values, not for discrete operations.
			For this reason encoding is performed to/from DataBuffer objects.
		* Objects that support Binary Encoding generally provide a static fromBinary() decode 
			function and a toBinary() member function.



Main Features
	* Program object: provide access to general functionality (i.e. args, env, random, logging, process IO, exit handling)
	* Useful Types: Memory, String, DataBuffer, Unicode
	* Interruptable Threads
	* Abstract IO & Readers, asio implementations



* Want to open an Input

	auto input1 = File::read( "filename.txt" );
	auto input2 = Http::get( "www.google.com" );
	auto input3 = Tcp::connect( "www.google.com:80" );

* Want to read all input until closed?

	String data = input.readAll();

* Want to read something asynchronously?

	Input input = ...;
	input.async(
		[]( const String & data )	// read function
			{
				print( "got data: %\n", data );
			},
		[]( std::error_code error ) // close function
			{
				if ( error )
				{
					print( "got error: %\n", error.message() );
				}
				else
				{
					print( "done!\n" );
				}
			},
		Program::bus() );
	
	while ( input )
		{ Program::update(); 
		
	}

* Want to iteratively read bytes?
	
	for ( auto cursor : input.bytes() )
	{
		print( cursor.data() );
	}


* Want to iteratively read lines?

	for ( auto cursor : input.lines() )
	{
		print( cursor.line() );
	}

* Want to iteratively regex search?

	for ( auto cursor : input.search( R"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})" ) )
	{
		print( "match #% at %bytes\n", cursor.matchIndex(), cursor.position() );
	}

* Want to read lines asynchronously?

	input.lines.async(
		[]( const LineReader::Cursor & cursor )
			{
			},
		[]( std::error_code error )
			{
			},
		Program::bus() );

	